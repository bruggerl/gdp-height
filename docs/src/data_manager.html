<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.data_manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.data_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import constants as c


class DataManager:
    &#34;&#34;&#34;
    This class encapsulates the logic for reading and processing the datasets.
    &#34;&#34;&#34;

    def __init__(self, heights_csv, gdps_csv):
        &#34;&#34;&#34;
        Initialize the DataManager with the given CSV inputs. The DataManager holds the input as
        pandas dataframes and saves the processed datasets as well as the merged output when the respective functions
        are called. When reading the &#34;average height&#34; dataset, only the columns &#39;Country&#39;, &#39;Sex&#39;, &#39;Year&#39;, &#39;Age group&#39;
        and &#39;Mean height&#39; are saved. When reading the &#34;GDP per capita&#34; dataset, only the columns &#39;Country Name&#39;,
        &#39;Country Code&#39; and &#39;2019&#39; are saved since we are only interested in data from 2019.

        :param heights_csv: path to the CSV file containing data about the average heights
        :param gdps_csv: path to the CSV file containing data about the GDP
        &#34;&#34;&#34;
        self.heights_input = pd.read_csv(heights_csv, usecols=[&#39;Country&#39;, &#39;Sex&#39;, &#39;Year&#39;, &#39;Age group&#39;, &#39;Mean height&#39;])
        self.gdps_input = pd.read_csv(gdps_csv, usecols=[&#39;Country Name&#39;, &#39;Country Code&#39;, &#39;2019&#39;])
        self.heights_processed = None
        self.gdps_processed = None
        self.output = None

    def process_datasets(self):
        &#34;&#34;&#34;
        Process the two datasets. The &#34;average heights&#34; dataset is filtered so that only the data entries from 2019 and
        for the age group 19 are considered (those columns are dropped in the next step because they contain the same
        value for each row). The &#39;Mean height&#39; column is renamed to a more meaningful name. Rows that contain a NaN
        value in the &#34;GDP per capita&#34; dataset are deleted. Additionally, the columns &#39;Country Name&#39;, &#39;2019&#39; and
        &#39;Country Code&#39; are renamed in order to be able to merge the two datasets and to provide meaningful column names.

        :return: nothing
        &#34;&#34;&#34;
        # PREPARE DATAFRAMES
        # filter heights: year 2019, age 19
        self.heights_processed = self.heights_input.loc[(self.heights_input[&#39;Year&#39;] == 2019) &amp; (self.heights_input[&#39;Age group&#39;] == 19)]

        self.heights_processed = self.heights_processed.drop(labels=[&#39;Year&#39;, &#39;Age group&#39;], axis=1)  # drop unnecessary columns
        self.heights_processed = self.heights_processed.rename(columns={&#39;Mean height&#39;: c.AVG_HEIGHT})

        self.gdps_processed = self.gdps_input.dropna(thresh=3)  # drop NaN GDPs
        self.gdps_processed = self.gdps_processed.rename(
            columns={&#39;Country Name&#39;: c.COUNTRY, &#39;2019&#39;: c.GDP, &#39;Country Code&#39;: c.COUNTRY_CODE})

    def merge_processed_datasets(self):
        &#34;&#34;&#34;
        Merge the processed datasets. The processed datasets are merged on the &#39;Country&#39; column which contains the
        name of the country. An exception is thrown if the datasets have not been processed yet (i.e., one of the
        datasets is None).

        :return: nothing
        &#34;&#34;&#34;
        if self.heights_processed is not None and self.gdps_processed is not None:
            # MERGE DATAFRAMES
            merged = pd.merge(self.gdps_processed, self.heights_processed, on=&#39;Country&#39;)
            self.output = merged
        else:
            raise Exception(&#39;Datasets have not been processed yet!&#39;)

    def export_csv(self):
        &#34;&#34;&#34;
        Export the resulting dataset to a CSV file. An exception is thrown if the result dataset has not been
        created yet.

        :return: nothing
        &#34;&#34;&#34;
        if self.output is not None:
            self.output.to_csv(&#39;out/gdp_avgHeight_per_country.csv&#39;, index_label=&#39;ID&#39;, index=True)
        else:
            raise Exception(&#39;No data produced yet!&#39;)

    def get_dataset_males(self):
        &#34;&#34;&#34;
        Get the filtered result dataframe which only contains records for 19-year-old males. An exception is thrown
        if the result dataset has not been created yet.

        :return: nothing
        &#34;&#34;&#34;
        if self.output is not None:
            return self.output.loc[(self.output[&#39;Sex&#39;] == &#39;Boys&#39;)].drop(labels=[&#39;Sex&#39;], axis=1)
        else:
            raise Exception(&#39;No data produced yet!&#39;)

    def get_dataset_females(self):
        &#34;&#34;&#34;
        Get the filtered result dataframe which only contains records for 19-year-old females. An exception is thrown
        if the result dataset has not been created yet.

        :return: nothing
        &#34;&#34;&#34;
        if self.output is not None:
            return self.output.loc[(self.output[&#39;Sex&#39;] == &#39;Girls&#39;)].drop(labels=[&#39;Sex&#39;], axis=1)
        else:
            raise Exception(&#39;No data produced yet!&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.data_manager.DataManager"><code class="flex name class">
<span>class <span class="ident">DataManager</span></span>
<span>(</span><span>heights_csv, gdps_csv)</span>
</code></dt>
<dd>
<div class="desc"><p>This class encapsulates the logic for reading and processing the datasets.</p>
<p>Initialize the DataManager with the given CSV inputs. The DataManager holds the input as
pandas dataframes and saves the processed datasets as well as the merged output when the respective functions
are called. When reading the "average height" dataset, only the columns 'Country', 'Sex', 'Year', 'Age group'
and 'Mean height' are saved. When reading the "GDP per capita" dataset, only the columns 'Country Name',
'Country Code' and '2019' are saved since we are only interested in data from 2019.</p>
<p>:param heights_csv: path to the CSV file containing data about the average heights
:param gdps_csv: path to the CSV file containing data about the GDP</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataManager:
    &#34;&#34;&#34;
    This class encapsulates the logic for reading and processing the datasets.
    &#34;&#34;&#34;

    def __init__(self, heights_csv, gdps_csv):
        &#34;&#34;&#34;
        Initialize the DataManager with the given CSV inputs. The DataManager holds the input as
        pandas dataframes and saves the processed datasets as well as the merged output when the respective functions
        are called. When reading the &#34;average height&#34; dataset, only the columns &#39;Country&#39;, &#39;Sex&#39;, &#39;Year&#39;, &#39;Age group&#39;
        and &#39;Mean height&#39; are saved. When reading the &#34;GDP per capita&#34; dataset, only the columns &#39;Country Name&#39;,
        &#39;Country Code&#39; and &#39;2019&#39; are saved since we are only interested in data from 2019.

        :param heights_csv: path to the CSV file containing data about the average heights
        :param gdps_csv: path to the CSV file containing data about the GDP
        &#34;&#34;&#34;
        self.heights_input = pd.read_csv(heights_csv, usecols=[&#39;Country&#39;, &#39;Sex&#39;, &#39;Year&#39;, &#39;Age group&#39;, &#39;Mean height&#39;])
        self.gdps_input = pd.read_csv(gdps_csv, usecols=[&#39;Country Name&#39;, &#39;Country Code&#39;, &#39;2019&#39;])
        self.heights_processed = None
        self.gdps_processed = None
        self.output = None

    def process_datasets(self):
        &#34;&#34;&#34;
        Process the two datasets. The &#34;average heights&#34; dataset is filtered so that only the data entries from 2019 and
        for the age group 19 are considered (those columns are dropped in the next step because they contain the same
        value for each row). The &#39;Mean height&#39; column is renamed to a more meaningful name. Rows that contain a NaN
        value in the &#34;GDP per capita&#34; dataset are deleted. Additionally, the columns &#39;Country Name&#39;, &#39;2019&#39; and
        &#39;Country Code&#39; are renamed in order to be able to merge the two datasets and to provide meaningful column names.

        :return: nothing
        &#34;&#34;&#34;
        # PREPARE DATAFRAMES
        # filter heights: year 2019, age 19
        self.heights_processed = self.heights_input.loc[(self.heights_input[&#39;Year&#39;] == 2019) &amp; (self.heights_input[&#39;Age group&#39;] == 19)]

        self.heights_processed = self.heights_processed.drop(labels=[&#39;Year&#39;, &#39;Age group&#39;], axis=1)  # drop unnecessary columns
        self.heights_processed = self.heights_processed.rename(columns={&#39;Mean height&#39;: c.AVG_HEIGHT})

        self.gdps_processed = self.gdps_input.dropna(thresh=3)  # drop NaN GDPs
        self.gdps_processed = self.gdps_processed.rename(
            columns={&#39;Country Name&#39;: c.COUNTRY, &#39;2019&#39;: c.GDP, &#39;Country Code&#39;: c.COUNTRY_CODE})

    def merge_processed_datasets(self):
        &#34;&#34;&#34;
        Merge the processed datasets. The processed datasets are merged on the &#39;Country&#39; column which contains the
        name of the country. An exception is thrown if the datasets have not been processed yet (i.e., one of the
        datasets is None).

        :return: nothing
        &#34;&#34;&#34;
        if self.heights_processed is not None and self.gdps_processed is not None:
            # MERGE DATAFRAMES
            merged = pd.merge(self.gdps_processed, self.heights_processed, on=&#39;Country&#39;)
            self.output = merged
        else:
            raise Exception(&#39;Datasets have not been processed yet!&#39;)

    def export_csv(self):
        &#34;&#34;&#34;
        Export the resulting dataset to a CSV file. An exception is thrown if the result dataset has not been
        created yet.

        :return: nothing
        &#34;&#34;&#34;
        if self.output is not None:
            self.output.to_csv(&#39;out/gdp_avgHeight_per_country.csv&#39;, index_label=&#39;ID&#39;, index=True)
        else:
            raise Exception(&#39;No data produced yet!&#39;)

    def get_dataset_males(self):
        &#34;&#34;&#34;
        Get the filtered result dataframe which only contains records for 19-year-old males. An exception is thrown
        if the result dataset has not been created yet.

        :return: nothing
        &#34;&#34;&#34;
        if self.output is not None:
            return self.output.loc[(self.output[&#39;Sex&#39;] == &#39;Boys&#39;)].drop(labels=[&#39;Sex&#39;], axis=1)
        else:
            raise Exception(&#39;No data produced yet!&#39;)

    def get_dataset_females(self):
        &#34;&#34;&#34;
        Get the filtered result dataframe which only contains records for 19-year-old females. An exception is thrown
        if the result dataset has not been created yet.

        :return: nothing
        &#34;&#34;&#34;
        if self.output is not None:
            return self.output.loc[(self.output[&#39;Sex&#39;] == &#39;Girls&#39;)].drop(labels=[&#39;Sex&#39;], axis=1)
        else:
            raise Exception(&#39;No data produced yet!&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.data_manager.DataManager.export_csv"><code class="name flex">
<span>def <span class="ident">export_csv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Export the resulting dataset to a CSV file. An exception is thrown if the result dataset has not been
created yet.</p>
<p>:return: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_csv(self):
    &#34;&#34;&#34;
    Export the resulting dataset to a CSV file. An exception is thrown if the result dataset has not been
    created yet.

    :return: nothing
    &#34;&#34;&#34;
    if self.output is not None:
        self.output.to_csv(&#39;out/gdp_avgHeight_per_country.csv&#39;, index_label=&#39;ID&#39;, index=True)
    else:
        raise Exception(&#39;No data produced yet!&#39;)</code></pre>
</details>
</dd>
<dt id="src.data_manager.DataManager.get_dataset_females"><code class="name flex">
<span>def <span class="ident">get_dataset_females</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the filtered result dataframe which only contains records for 19-year-old females. An exception is thrown
if the result dataset has not been created yet.</p>
<p>:return: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dataset_females(self):
    &#34;&#34;&#34;
    Get the filtered result dataframe which only contains records for 19-year-old females. An exception is thrown
    if the result dataset has not been created yet.

    :return: nothing
    &#34;&#34;&#34;
    if self.output is not None:
        return self.output.loc[(self.output[&#39;Sex&#39;] == &#39;Girls&#39;)].drop(labels=[&#39;Sex&#39;], axis=1)
    else:
        raise Exception(&#39;No data produced yet!&#39;)</code></pre>
</details>
</dd>
<dt id="src.data_manager.DataManager.get_dataset_males"><code class="name flex">
<span>def <span class="ident">get_dataset_males</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the filtered result dataframe which only contains records for 19-year-old males. An exception is thrown
if the result dataset has not been created yet.</p>
<p>:return: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dataset_males(self):
    &#34;&#34;&#34;
    Get the filtered result dataframe which only contains records for 19-year-old males. An exception is thrown
    if the result dataset has not been created yet.

    :return: nothing
    &#34;&#34;&#34;
    if self.output is not None:
        return self.output.loc[(self.output[&#39;Sex&#39;] == &#39;Boys&#39;)].drop(labels=[&#39;Sex&#39;], axis=1)
    else:
        raise Exception(&#39;No data produced yet!&#39;)</code></pre>
</details>
</dd>
<dt id="src.data_manager.DataManager.merge_processed_datasets"><code class="name flex">
<span>def <span class="ident">merge_processed_datasets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge the processed datasets. The processed datasets are merged on the 'Country' column which contains the
name of the country. An exception is thrown if the datasets have not been processed yet (i.e., one of the
datasets is None).</p>
<p>:return: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_processed_datasets(self):
    &#34;&#34;&#34;
    Merge the processed datasets. The processed datasets are merged on the &#39;Country&#39; column which contains the
    name of the country. An exception is thrown if the datasets have not been processed yet (i.e., one of the
    datasets is None).

    :return: nothing
    &#34;&#34;&#34;
    if self.heights_processed is not None and self.gdps_processed is not None:
        # MERGE DATAFRAMES
        merged = pd.merge(self.gdps_processed, self.heights_processed, on=&#39;Country&#39;)
        self.output = merged
    else:
        raise Exception(&#39;Datasets have not been processed yet!&#39;)</code></pre>
</details>
</dd>
<dt id="src.data_manager.DataManager.process_datasets"><code class="name flex">
<span>def <span class="ident">process_datasets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Process the two datasets. The "average heights" dataset is filtered so that only the data entries from 2019 and
for the age group 19 are considered (those columns are dropped in the next step because they contain the same
value for each row). The 'Mean height' column is renamed to a more meaningful name. Rows that contain a NaN
value in the "GDP per capita" dataset are deleted. Additionally, the columns 'Country Name', '2019' and
'Country Code' are renamed in order to be able to merge the two datasets and to provide meaningful column names.</p>
<p>:return: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_datasets(self):
    &#34;&#34;&#34;
    Process the two datasets. The &#34;average heights&#34; dataset is filtered so that only the data entries from 2019 and
    for the age group 19 are considered (those columns are dropped in the next step because they contain the same
    value for each row). The &#39;Mean height&#39; column is renamed to a more meaningful name. Rows that contain a NaN
    value in the &#34;GDP per capita&#34; dataset are deleted. Additionally, the columns &#39;Country Name&#39;, &#39;2019&#39; and
    &#39;Country Code&#39; are renamed in order to be able to merge the two datasets and to provide meaningful column names.

    :return: nothing
    &#34;&#34;&#34;
    # PREPARE DATAFRAMES
    # filter heights: year 2019, age 19
    self.heights_processed = self.heights_input.loc[(self.heights_input[&#39;Year&#39;] == 2019) &amp; (self.heights_input[&#39;Age group&#39;] == 19)]

    self.heights_processed = self.heights_processed.drop(labels=[&#39;Year&#39;, &#39;Age group&#39;], axis=1)  # drop unnecessary columns
    self.heights_processed = self.heights_processed.rename(columns={&#39;Mean height&#39;: c.AVG_HEIGHT})

    self.gdps_processed = self.gdps_input.dropna(thresh=3)  # drop NaN GDPs
    self.gdps_processed = self.gdps_processed.rename(
        columns={&#39;Country Name&#39;: c.COUNTRY, &#39;2019&#39;: c.GDP, &#39;Country Code&#39;: c.COUNTRY_CODE})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.data_manager.DataManager" href="#src.data_manager.DataManager">DataManager</a></code></h4>
<ul class="">
<li><code><a title="src.data_manager.DataManager.export_csv" href="#src.data_manager.DataManager.export_csv">export_csv</a></code></li>
<li><code><a title="src.data_manager.DataManager.get_dataset_females" href="#src.data_manager.DataManager.get_dataset_females">get_dataset_females</a></code></li>
<li><code><a title="src.data_manager.DataManager.get_dataset_males" href="#src.data_manager.DataManager.get_dataset_males">get_dataset_males</a></code></li>
<li><code><a title="src.data_manager.DataManager.merge_processed_datasets" href="#src.data_manager.DataManager.merge_processed_datasets">merge_processed_datasets</a></code></li>
<li><code><a title="src.data_manager.DataManager.process_datasets" href="#src.data_manager.DataManager.process_datasets">process_datasets</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>